\chapter{Introduction}

The query language is the singular interface for accessing, reading, creating
and removing data in a database. This requires the query language to provide a
high degree of performance in the sense of performing processing intensive
queries in a fast enough time for real-time responsiveness, especially for an
in memory data store with the aspiration for high performance.

Optimisations for database query languages are common, such as in the
embeddable Database \textit{SQLite} with the \textit{SQLite Query
Optimizer}\cite{sqlite_query_opt} and the \textit{Next-Generation Query
Planner}\cite{sqlite_query_opt} both supporting a variety of optimisations
after compiling SQL expressions to byte-code instead of walking the
AST\footnote{Abstract Syntax Tree: tree of syntax
nodes}\cite{sqlite_next_gen_query_plan}. \textit{PostgreSQL} is an other
example of a database optimising its SQL queries, using a JIT compiler\footnote{Just in
time compiler: compiling methods on demand while a program is running \cite[1.
Introduction]{java_jit_compilation}}\cite{postgres_jit}.

There are several optimisations applicable for any programming language and
query languages in particular. Some were already applied to the query language
\cite{parser2_opt}. Implementing a JIT compiler can significantly improve the
performance of a long running highly processing intensive program and allows it
to outperform optimisations applied to the AST before walking it or compiling
to bytecode instructions and executing them in a dedicated virtual machine
\cite[4. Results]{java_jit_compilation}. To evaluate whether the expensive
startup time is rewarding the query language runtime with higher performance
will be tested as part of this paper.

\chapter{Conclusion}

To evaluate wheter the go plugin api is feasible for just in time compilation
one must consider the usability and robustness of the resulting implementation.
Furthermore it is crusial to take the resulting performance impact of the
solution into account, while not neglecting the complexity of the
implementation. The following section includes in depth examination of the
above criteria to conclude on the aforementioned consideration.

\section{Usability and Robustness}

The limiting usability factor is the requirement to have a local copy of the go
toolchain available. This makes user interaction in the way of installing the
go compiler necessary. 

% TODO: no support for windows -> excludes a large user base

\section{Performance}

Based on performed benchmarks (see \autoref{sec:benchmarks}), their results and
visual representation, the performance impact of the JIT-Compiler is
substantial for most workloads, but especially for larger iterations, such as
in hot paths. The Go compiler optimises compiled plugins as if it were to
compile a Go application, such as reducing memory allocations\cite[Escape
Analysis]{go_wiki_optimization}, inlining
functions\cite[Inlining]{go_wiki_optimization} and not allocating empty
structures \cite[Interface Values]{go_wiki_optimization}. This allows the
interpreter to leverage the optimized performance the Go compiler applies to
binaries it compiles, thus enabling the observed large performance improvements
for string manipulation and arithmetic operations.

However the overhead of walking the tree to generate go code from each node,
writing this code to a file, invoking the local go compiler via the
\texttt{os/exec} package, loading the go plugin and looking the compiled
function up, can not be neglected. Due to said influences Jit compilation
is inherently unsuitable for small workloads and fast executing inputs, as seen
on the workloads, inputs and iteration counts choosen for the benchmarks. 

\section{Implementation Complexity}

Due to the architecture of the runtime, the abstract syntax tree for a given
node is available while evaluating said node. The just-in-time compiler can
therefore use this tree to generate go code for every encountered node.
Furthermore the just-in-time compiler uses the existing runtime facilities for
performing meta tracing and asserting types. While the runtime architecture is
advantageous for the above, it made designing and implementing the just-in-time
compiler itself complex. There are several reasons for this, foremost the
package architecture, the just-in-time compiler has to depend on multiple
packages and use type assertions for custom types defined in subpackages, thus
it can not extracted into a signular \texttt{jit} package. Furthermore the
runtime was designed to be used with a generic language and using the go
generics feature. This made it especially complicated to implement type
assertions and type conversion for the generated go code, this is also the
reason for the introduction of the functions presented in
\autoref{sec:type-system-clashes} and the need for including the implementation
of these functions when defining a language for the runtime.

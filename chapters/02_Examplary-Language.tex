\chapter{Query Language}

The query language is generic by design and by usage of the newly introduced
generic proposal \cite{go_generic_proposal}. This allows for rudimentary and
complex language variations depending on the data type the desired language is
created with. Such as complexity ranging from boolean algebra (see
\autoref{code:language-example-boolean} and its corresponding language
definition \autoref{code:language-example-boolean-gen}), over arithmetic
operations to complex queries on lists of objects, such as filtering for
values, mapping and mutating elements of the list and iterating over the
entries of the list.

\begin{listing}[H]
    \begin{minted}{bash}
true | false
a & !b
let c=true;
if c then 
    a&b 
else 
    a|b
    \end{minted}
    \caption{Boolean algebra}
    \label{code:language-example-boolean}
\end{listing}

\begin{listing}[H]
    \begin{minted}{go}
var boolParser = funcGen.New[bool]()
    .AddConstant("false", false)
    .AddConstant("true", true)
    .AddSimpleOp("^", true, 
            func(a, b bool) (bool, error) { return a != b, nil })
    .AddSimpleOp("=", true, 
            func(a, b bool) (bool, error) { return a == b, nil })
    .AddSimpleOp("|", true, 
            func(a, b bool) (bool, error) { return a || b, nil })
    .AddSimpleOp("&", true, 
            func(a, b bool) (bool, error) { return a && b, nil })
    .AddUnary("!", func(a bool) (bool, error) { return !a, nil })
    .SetToBool(func(c bool) (bool, bool) { return c, true })
    \end{minted}
    \caption{Generating boolean algebra}
    \label{code:language-example-boolean-gen}
\end{listing}

\section{Feature set}

To limit the scope of performance evaluation, the feature set is determined as
the  language definition and dialect\footnote{Refers to the usage of
\cite{parser2_xnacly} to define and generate a language for a specific data
type, with static global functions and constant values}, specified in the
\texttt{value} package of the \texttt{parser2} \cite[\texttt{value}
package]{parser2_xnacly} project. This dialect allows for aggregation,
filtering and mutating large lists of data sets consisting of objects with many
key value pairs.

% TODO: show example with persons, show streaming, explain usage

\section{Evaluation Approach}

% TODO: explain:
% - ast walker
% - performs optimisations such as consts eval, etc
% - generates functions from the AST, equates to a simple ast walker

